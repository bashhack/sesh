diff --git a/fix-keychain.go b/fix-keychain.go
index ab40600..6435c93 100644
--- a/fix-keychain.go
+++ b/fix-keychain.go
@@ -10,24 +10,24 @@ import (
 // One-time utility to fix keychain access prompts
 func main() {
 	fmt.Println("üîê Updating keychain access for sesh...")
-	
+
 	// Get current user
 	username, err := exec.Command("whoami").Output()
 	if err != nil {
 		fmt.Printf("Error getting username: %v\n", err)
 		os.Exit(1)
 	}
-	
+
 	user := strings.TrimSpace(string(username))
 	fmt.Printf("Current user: %s\n", user)
-	
+
 	// Get all available sesh binaries
 	installedPaths := []string{
 		"/Users/" + user + "/.local/bin/sesh",
 		"/usr/local/bin/sesh",
 		"/opt/homebrew/bin/sesh",
 	}
-	
+
 	// Find which ones exist
 	var validPaths []string
 	for _, path := range installedPaths {
@@ -36,18 +36,18 @@ func main() {
 			fmt.Printf("Found sesh binary: %s\n", path)
 		}
 	}
-	
+
 	if len(validPaths) == 0 {
 		fmt.Println("No sesh binaries found!")
 		os.Exit(1)
 	}
-	
+
 	// Find all keychain entries
 	servicesToFix := []string{
 		"sesh-mfa",
 		"sesh-mfa-serial",
 	}
-	
+
 	// Get entries with profile names too
 	output, err := exec.Command("security", "dump-keychain").Output()
 	if err == nil {
@@ -62,20 +62,20 @@ func main() {
 			}
 		}
 	}
-	
+
 	fmt.Println("Services to fix:")
 	for _, service := range servicesToFix {
 		fmt.Printf("  - %s\n", service)
 	}
-	
+
 	// Update each service with all valid paths
 	tArgs := []string{}
 	for _, path := range validPaths {
-		tArgs = append(tArgs, "-T", path) 
+		tArgs = append(tArgs, "-T", path)
 	}
-	
+
 	fmt.Println("Attempting to fix keychain access...")
-	
+
 	for _, service := range servicesToFix {
 		// Check if this entry exists
 		checkCmd := exec.Command("security", "find-generic-password", "-s", service, "-a", user)
@@ -83,7 +83,7 @@ func main() {
 			fmt.Printf("Service '%s' not found, skipping\n", service)
 			continue
 		}
-		
+
 		// Get the current password
 		pwdCmd := exec.Command("security", "find-generic-password", "-s", service, "-a", user, "-w")
 		pwd, err := pwdCmd.Output()
@@ -91,14 +91,14 @@ func main() {
 			fmt.Printf("Error reading password for '%s': %v\n", service, err)
 			continue
 		}
-		
+
 		// Delete the old entry
 		delCmd := exec.Command("security", "delete-generic-password", "-s", service, "-a", user)
 		if err := delCmd.Run(); err != nil {
 			fmt.Printf("Error deleting entry for '%s': %v\n", service, err)
 			continue
 		}
-		
+
 		// Create a new entry with all paths
 		args := []string{
 			"add-generic-password",
@@ -108,17 +108,17 @@ func main() {
 			"-U",
 		}
 		args = append(args, tArgs...)
-		
+
 		addCmd := exec.Command("security", args...)
 		if err := addCmd.Run(); err != nil {
 			fmt.Printf("Error creating new entry for '%s': %v\n", service, err)
 			continue
 		}
-		
+
 		fmt.Printf("‚úÖ Fixed access for '%s'\n", service)
 	}
-	
+
 	fmt.Println("\nüîê Keychain access update complete!")
 	fmt.Println("You should no longer receive multiple security prompts.")
 	fmt.Println("If you still have issues, try running 'sesh --setup' to re-create your entries.")
-}
\ No newline at end of file
+}
diff --git a/go.mod b/go.mod
index f4dd068..e55ca5f 100644
--- a/go.mod
+++ b/go.mod
@@ -2,11 +2,13 @@ module github.com/bashhack/sesh
 
 go 1.24.0
 
-require github.com/pquerna/otp v1.4.0
+require (
+	github.com/klauspost/compress v1.18.0
+	github.com/pquerna/otp v1.4.0
+	golang.org/x/term v0.31.0
+)
 
 require (
 	github.com/boombuler/barcode v1.0.1 // indirect
-	github.com/peterbourgon/ff/v4 v4.0.0-alpha.4 // indirect
 	golang.org/x/sys v0.32.0 // indirect
-	golang.org/x/term v0.31.0 // indirect
 )
diff --git a/go.sum b/go.sum
index c3c90f0..462802a 100644
--- a/go.sum
+++ b/go.sum
@@ -3,8 +3,8 @@ github.com/boombuler/barcode v1.0.1 h1:NDBbPmhS+EqABEs5Kg3n/5ZNjy73Pz7SIV+KCeqyX
 github.com/boombuler/barcode v1.0.1/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=
 github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
-github.com/peterbourgon/ff/v4 v4.0.0-alpha.4 h1:aiqS8aBlF9PsAKeMddMSfbwp3smONCn3UO8QfUg0Z7Y=
-github.com/peterbourgon/ff/v4 v4.0.0-alpha.4/go.mod h1:H/13DK46DKXy7EaIxPhk2Y0EC8aubKm35nBjBe8AAGc=
+github.com/klauspost/compress v1.18.0 h1:c/Cqfb0r+Yi+JtIEq73FWXVkRonBlf0CRNYc8Zttxdo=
+github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=
 github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/pquerna/otp v1.4.0 h1:wZvl1TIVxKRThZIBiwOOHOGP/1+nZyWBil9Y2XNEDzg=
diff --git a/internal/clipboard/clipboard.go b/internal/clipboard/clipboard.go
index 7bb6341..891e584 100644
--- a/internal/clipboard/clipboard.go
+++ b/internal/clipboard/clipboard.go
@@ -27,19 +27,19 @@ func copyOSX(text string) error {
 	if err != nil {
 		return err
 	}
-	
+
 	if err := cmd.Start(); err != nil {
 		return err
 	}
-	
+
 	if _, err := pipe.Write([]byte(text)); err != nil {
 		return err
 	}
-	
+
 	if err := pipe.Close(); err != nil {
 		return err
 	}
-	
+
 	return cmd.Wait()
 }
 
@@ -57,26 +57,26 @@ func copyLinux(text string) error {
 			}
 		}
 	}
-	
+
 	// Try xsel if xclip failed
 	cmd = exec.Command("xsel", "--clipboard", "--input")
 	pipe, err = cmd.StdinPipe()
 	if err != nil {
 		return fmt.Errorf("no clipboard utility available: install xclip or xsel")
 	}
-	
+
 	if err := cmd.Start(); err != nil {
 		return err
 	}
-	
+
 	if _, err := pipe.Write([]byte(text)); err != nil {
 		return err
 	}
-	
+
 	if err := pipe.Close(); err != nil {
 		return err
 	}
-	
+
 	return cmd.Wait()
 }
 
@@ -84,4 +84,4 @@ func copyLinux(text string) error {
 func copyWindows(text string) error {
 	cmd := exec.Command("powershell", "-command", "Set-Clipboard", "-Value", text)
 	return cmd.Run()
-}
\ No newline at end of file
+}
diff --git a/internal/constants/constants.go b/internal/constants/constants.go
index 4d8f143..f3228ff 100644
--- a/internal/constants/constants.go
+++ b/internal/constants/constants.go
@@ -5,7 +5,7 @@ const (
 	AWSServiceMFAPrefix = "sesh-aws-serial"
 
 	TOTPServicePrefix = "sesh-totp"
-	
+
 	// MetadataServiceName is the single keychain entry name used to store all metadata
 	MetadataServiceName = "sesh-metadata"
 )
diff --git a/internal/keychain/interfaces.go b/internal/keychain/interfaces.go
index 0635ca5..d322729 100644
--- a/internal/keychain/interfaces.go
+++ b/internal/keychain/interfaces.go
@@ -59,4 +59,4 @@ func (p *DefaultProvider) DeleteEntry(account, service string) error {
 // NewDefaultProvider creates a new DefaultProvider
 func NewDefaultProvider() Provider {
 	return &DefaultProvider{}
-}
\ No newline at end of file
+}
diff --git a/internal/keychain/keychain.go b/internal/keychain/keychain.go
index a0248d0..3de3292 100644
--- a/internal/keychain/keychain.go
+++ b/internal/keychain/keychain.go
@@ -10,6 +10,7 @@ import (
 )
 
 var execCommand = exec.Command
+
 // Default installation path as a fallback
 var seshBinaryPath = "/usr/local/bin/sesh"
 
@@ -23,20 +24,20 @@ func getCurrentExecutablePath() string {
 			return selfPath
 		}
 	}
-	
+
 	// Otherwise, check for known installation paths
 	knownPaths := []string{
 		os.ExpandEnv("$HOME/.local/bin/sesh"),
 		"/usr/local/bin/sesh",
 		"/opt/homebrew/bin/sesh",
 	}
-	
+
 	for _, path := range knownPaths {
 		if _, err := os.Stat(path); err == nil {
 			return path
 		}
 	}
-	
+
 	// Fall back to the default as a last resort
 	return seshBinaryPath
 }
@@ -62,7 +63,7 @@ func GetSecret(account, service string) (string, error) {
 	// Debug the current binary path at time of access
 	execPath := getCurrentExecutablePath()
 	fmt.Fprintf(os.Stderr, "DEBUG: Current binary path used for keychain access: %s\n", execPath)
-	
+
 	cmd := execCommand("security", "find-generic-password",
 		"-a", account,
 		"-s", service,
@@ -95,13 +96,13 @@ func SetSecret(account, service, secret string) error {
 
 	// Get the current executable path at the time of access
 	execPath := getCurrentExecutablePath()
-	
+
 	// Allow only the sesh binary to access this keychain item
 	cmd := execCommand("security", "add-generic-password",
 		"-a", account,
 		"-s", service,
 		"-w", secret,
-		"-U", // Update if exists
+		"-U",           // Update if exists
 		"-T", execPath, // Only allow the sesh binary to access this item
 	)
 
@@ -172,7 +173,7 @@ func ListEntries(servicePrefix string) ([]KeychainEntry, error) {
 	// Parse the output to find matching entries
 	// Each keychain entry is enclosed in blocks of "attributes:", "data:", etc
 	var entries []KeychainEntry
-	
+
 	// Split output by keychain items
 	itemPattern := regexp.MustCompile(`(?s)keychain: "[^"]+"\s+class: "genp".*?data:.*?$`)
 	items := itemPattern.FindAllString(output, -1)
@@ -186,7 +187,7 @@ func ListEntries(servicePrefix string) ([]KeychainEntry, error) {
 				continue
 			}
 			service := serviceMatch[1]
-			
+
 			// Parse the account name
 			accountMatch := regexp.MustCompile(`"acct"<blob>="([^"]+)"`).FindStringSubmatch(item)
 			if len(accountMatch) < 2 {
@@ -250,4 +251,4 @@ func DeleteEntry(account, service string) error {
 	}
 
 	return nil
-}
\ No newline at end of file
+}
diff --git a/internal/keychain/keychain_test.go b/internal/keychain/keychain_test.go
index 24a0587..68ae10b 100644
--- a/internal/keychain/keychain_test.go
+++ b/internal/keychain/keychain_test.go
@@ -494,4 +494,4 @@ func randomString(length int) string {
 
 func TestHelperProcess(*testing.T) {
 	testutil.TestHelperProcess()
-}
\ No newline at end of file
+}
diff --git a/internal/keychain/metadata.go b/internal/keychain/metadata.go
index 2461ada..2cc7f4f 100644
--- a/internal/keychain/metadata.go
+++ b/internal/keychain/metadata.go
@@ -168,7 +168,7 @@ func saveEntryMetadata(entries []KeychainEntryMeta) error {
 
 	// Compress the data
 	comp := zstdEncoder.EncodeAll(jsonData, nil)
-	
+
 	// Base64 encode the compressed data to avoid binary data issues
 	b64Data := base64.StdEncoding.EncodeToString(comp)
 
@@ -233,4 +233,4 @@ func getServicePrefix(service string) string {
 		return fmt.Sprintf("%s-%s", parts[0], parts[1])
 	}
 	return service
-}
\ No newline at end of file
+}
diff --git a/internal/provider/aws/provider.go b/internal/provider/aws/provider.go
index ba888c8..3005ed8 100644
--- a/internal/provider/aws/provider.go
+++ b/internal/provider/aws/provider.go
@@ -146,19 +146,19 @@ func (p *Provider) GetCredentials() (provider.Credentials, error) {
 
 	// Get the seconds left in current time window
 	secondsLeft := 30 - (time.Now().Unix() % 30)
-	
+
 	// First try with the current code
 	code := currentCode
 	fmt.Fprintf(os.Stderr, "üîë Trying authentication with code: %s (time window: %d seconds left)\n", code, secondsLeft)
-	
+
 	// Try the first code
 	awsCreds, err := p.aws.GetSessionToken(p.profile, serial, code)
-	
+
 	// Check if this is an "invalid MFA one time pass code" error, which could indicate a recently used code
 	if err != nil {
 		errStr := err.Error()
 		isInvalidMFA := strings.Contains(errStr, "MultiFactorAuthentication failed with invalid MFA one time pass code")
-		
+
 		// If it's an invalid MFA code or if we're close to time boundary, try the next code
 		if isInvalidMFA || secondsLeft < 5 {
 			if isInvalidMFA {
@@ -166,17 +166,17 @@ func (p *Provider) GetCredentials() (provider.Credentials, error) {
 			} else {
 				fmt.Fprintf(os.Stderr, "‚ö†Ô∏è Current code failed - time window nearly expired\n")
 			}
-			
-			// Try with the next time window's code 
+
+			// Try with the next time window's code
 			fmt.Fprintf(os.Stderr, "üîë Trying with next time window's code: %s\n", nextCode)
 			code = nextCode
 			awsCreds, err = p.aws.GetSessionToken(p.profile, serial, code)
-			
+
 			// If STILL failing and we're not close to boundary, and we have a "recently used" error,
 			// we may need to wait for the next time window
 			if err != nil && isInvalidMFA && secondsLeft > 10 {
 				fmt.Fprintf(os.Stderr, "‚ö†Ô∏è Both current and next codes were rejected - may need to wait for next time window\n")
-				
+
 				// Generate a code for the window after next, in case AWS is far ahead of our clock
 				futureCode, gErr := p.totp.GenerateForTime(secret, time.Now().Add(60*time.Second))
 				if gErr == nil {
@@ -187,7 +187,7 @@ func (p *Provider) GetCredentials() (provider.Credentials, error) {
 			}
 		}
 	}
-	
+
 	// If still failing, return the error
 	if err != nil {
 		// Check if this looks like a "code already used" error
@@ -342,7 +342,7 @@ func (p *Provider) GetTOTPKeyInfo() (string, string, error) {
 			return "", "", fmt.Errorf("could not determine current user: %w", err)
 		}
 	}
-	
+
 	// Determine the keychain key name based on profile
 	var keyName string
 	if p.profile == "" {
@@ -351,7 +351,7 @@ func (p *Provider) GetTOTPKeyInfo() (string, string, error) {
 	} else {
 		keyName = fmt.Sprintf("%s-%s", p.keyName, p.profile)
 	}
-	
+
 	return p.keyUser, keyName, nil
 }
 
@@ -360,7 +360,7 @@ func (p *Provider) GetMFASerial() (string, error) {
 	// Use the same logic as in GetCredentials but just return the serial
 	// Service name for the MFA serial (account for profile)
 	var serialService string
-	
+
 	// Get current user if not set
 	if p.keyUser == "" {
 		var err error
@@ -369,7 +369,7 @@ func (p *Provider) GetMFASerial() (string, error) {
 			return "", fmt.Errorf("could not determine current user: %w", err)
 		}
 	}
-	
+
 	if p.profile == "" {
 		// Use default for the default profile
 		serialService = fmt.Sprintf("%s-default", constants.AWSServiceMFAPrefix)
diff --git a/internal/provider/registry.go b/internal/provider/registry.go
index 5893f9d..5462a0d 100644
--- a/internal/provider/registry.go
+++ b/internal/provider/registry.go
@@ -29,12 +29,12 @@ func (r *Registry) RegisterProvider(provider ServiceProvider) {
 func (r *Registry) GetProvider(name string) (ServiceProvider, error) {
 	r.mu.RLock()
 	defer r.mu.RUnlock()
-	
+
 	p, ok := r.providers[name]
 	if !ok {
 		return nil, fmt.Errorf("provider %q not found", name)
 	}
-	
+
 	return p, nil
 }
 
@@ -42,11 +42,11 @@ func (r *Registry) GetProvider(name string) (ServiceProvider, error) {
 func (r *Registry) ListProviders() []ServiceProvider {
 	r.mu.RLock()
 	defer r.mu.RUnlock()
-	
+
 	result := make([]ServiceProvider, 0, len(r.providers))
 	for _, p := range r.providers {
 		result = append(result, p)
 	}
-	
+
 	return result
-}
\ No newline at end of file
+}
diff --git a/internal/provider/registry_test.go b/internal/provider/registry_test.go
index 7fc3f56..301f801 100644
--- a/internal/provider/registry_test.go
+++ b/internal/provider/registry_test.go
@@ -57,14 +57,14 @@ func (p *mockProvider) DeleteEntry(id string) error {
 
 func TestRegistry_RegisterProvider(t *testing.T) {
 	registry := NewRegistry()
-	
+
 	provider1 := &mockProvider{name: "test1", description: "Test Provider 1"}
 	provider2 := &mockProvider{name: "test2", description: "Test Provider 2"}
-	
+
 	// Register providers
 	registry.RegisterProvider(provider1)
 	registry.RegisterProvider(provider2)
-	
+
 	// Test GetProvider
 	p1, err := registry.GetProvider("test1")
 	if err != nil {
@@ -73,7 +73,7 @@ func TestRegistry_RegisterProvider(t *testing.T) {
 	if p1.Name() != "test1" {
 		t.Errorf("Expected provider name 'test1', got '%s'", p1.Name())
 	}
-	
+
 	p2, err := registry.GetProvider("test2")
 	if err != nil {
 		t.Errorf("Expected no error, got %v", err)
@@ -81,7 +81,7 @@ func TestRegistry_RegisterProvider(t *testing.T) {
 	if p2.Name() != "test2" {
 		t.Errorf("Expected provider name 'test2', got '%s'", p2.Name())
 	}
-	
+
 	// Test GetProvider for unknown provider
 	_, err = registry.GetProvider("unknown")
 	if err == nil {
@@ -91,30 +91,30 @@ func TestRegistry_RegisterProvider(t *testing.T) {
 
 func TestRegistry_ListProviders(t *testing.T) {
 	registry := NewRegistry()
-	
+
 	// Empty registry
 	providers := registry.ListProviders()
 	if len(providers) != 0 {
 		t.Errorf("Expected empty list, got %d providers", len(providers))
 	}
-	
+
 	// Add providers
 	provider1 := &mockProvider{name: "test1", description: "Test Provider 1"}
 	provider2 := &mockProvider{name: "test2", description: "Test Provider 2"}
-	
+
 	registry.RegisterProvider(provider1)
 	registry.RegisterProvider(provider2)
-	
+
 	// List providers
 	providers = registry.ListProviders()
 	if len(providers) != 2 {
 		t.Errorf("Expected 2 providers, got %d", len(providers))
 	}
-	
+
 	// Check if providers are in the list
 	foundProvider1 := false
 	foundProvider2 := false
-	
+
 	for _, p := range providers {
 		if p.Name() == "test1" {
 			foundProvider1 = true
@@ -123,11 +123,11 @@ func TestRegistry_ListProviders(t *testing.T) {
 			foundProvider2 = true
 		}
 	}
-	
+
 	if !foundProvider1 {
 		t.Error("Provider 'test1' not found in list")
 	}
 	if !foundProvider2 {
 		t.Error("Provider 'test2' not found in list")
 	}
-}
\ No newline at end of file
+}
diff --git a/internal/provider/totp/provider.go b/internal/provider/totp/provider.go
index ec41e23..9dc75a7 100644
--- a/internal/provider/totp/provider.go
+++ b/internal/provider/totp/provider.go
@@ -2,7 +2,6 @@ package totp
 
 import (
 	"bytes"
-	"flag"
 	"fmt"
 	"os"
 	"os/exec"
@@ -24,7 +23,7 @@ type Provider struct {
 	keychain    keychain.Provider
 	totp        internalTotp.Provider
 	setupWizard setup.WizardRunner
-	
+
 	// Flags
 	serviceName string
 	keyUser     string
@@ -61,17 +60,18 @@ func (p *Provider) Description() string {
 }
 
 // SetupFlags adds provider-specific flags to the given FlagSet
-func (p *Provider) SetupFlags(fs *flag.FlagSet) {
+func (p *Provider) SetupFlags(fs provider.FlagSet) error {
 	fs.StringVar(&p.serviceName, "service-name", "", "Name of the service to authenticate with")
 	fs.StringVar(&p.keyUser, "keychain-user", os.Getenv("SESH_KEYCHAIN_USER"), "macOS Keychain username (optional)")
 	fs.StringVar(&p.label, "label", "", "Label to identify this TOTP entry")
 	fs.StringVar(&p.profile, "profile", "", "Profile name for the service (for multiple accounts)")
-	
+
 	defaultKeyName := os.Getenv("SESH_TOTP_KEYCHAIN_NAME")
 	if defaultKeyName == "" {
 		defaultKeyName = defaultServicePrefix
 	}
 	fs.StringVar(&p.keyName, "keychain-name", defaultKeyName, "macOS Keychain service name prefix")
+	return nil
 }
 
 // Setup runs the setup wizard for TOTP
@@ -84,22 +84,22 @@ func (p *Provider) GetCredentials() (provider.Credentials, error) {
 	if p.serviceName == "" {
 		return provider.Credentials{}, fmt.Errorf("service name is required, use --service-name flag")
 	}
-	
+
 	// Get TOTP secret from keychain
 	serviceKey := buildServiceKey(p.keyName, p.serviceName, p.profile)
-	
+
 	fmt.Fprintf(os.Stderr, "DEBUG: Accessing TOTP service '%s' with user '%s'\n", serviceKey, p.keyUser)
-	
+
 	// Try direct keychain access first
-	cmd := exec.Command("security", "find-generic-password", 
-		"-a", p.keyUser, 
+	cmd := exec.Command("security", "find-generic-password",
+		"-a", p.keyUser,
 		"-s", serviceKey,
 		"-w")
 	var stdout bytes.Buffer
 	cmd.Stdout = &stdout
 	var secret string
 	var err error
-	
+
 	if cmd.Run() == nil {
 		secret = strings.TrimSpace(stdout.String())
 	} else {
@@ -109,16 +109,16 @@ func (p *Provider) GetCredentials() (provider.Credentials, error) {
 			return provider.Credentials{}, fmt.Errorf("could not retrieve TOTP secret for %s: %w", p.serviceName, err)
 		}
 	}
-	
+
 	// Generate TOTP code
 	code, err := p.totp.Generate(secret)
 	if err != nil {
 		return provider.Credentials{}, fmt.Errorf("could not generate TOTP code: %w", err)
 	}
-	
+
 	// Generate next code for display
 	_, next, err := p.totp.GenerateConsecutiveCodes(secret)
-	
+
 	// Calculate when this code expires (30 seconds from now, rounded to nearest 30s boundary)
 	now := time.Now().Unix()
 	validUntil := time.Unix(((now/30)+1)*30, 0)
@@ -128,7 +128,7 @@ func (p *Provider) GetCredentials() (provider.Credentials, error) {
 	if p.profile != "" {
 		displayName = fmt.Sprintf("%s (%s)", p.serviceName, p.profile)
 	}
-	
+
 	// Create credentials object
 	return provider.Credentials{
 		Provider:    p.Name(),
@@ -145,33 +145,33 @@ func (p *Provider) ListEntries() ([]provider.ProviderEntry, error) {
 	if err != nil {
 		return nil, fmt.Errorf("failed to list TOTP entries: %w", err)
 	}
-	
+
 	result := make([]provider.ProviderEntry, 0, len(entries))
 	for _, entry := range entries {
 		// Extract service name from the service key
 		serviceName, profile := parseServiceKey(entry.Service)
-		
+
 		// Skip entries that don't match our prefix pattern
 		if !strings.HasPrefix(entry.Service, p.keyName) {
 			continue
 		}
-		
+
 		// Format name based on whether a profile exists
 		displayName := serviceName
 		description := fmt.Sprintf("TOTP for %s", serviceName)
-		
+
 		if profile != "" {
 			displayName = fmt.Sprintf("%s (%s)", serviceName, profile)
 			description = fmt.Sprintf("TOTP for %s profile %s", serviceName, profile)
 		}
-		
+
 		result = append(result, provider.ProviderEntry{
 			Name:        displayName,
 			Description: description,
 			ID:          fmt.Sprintf("%s:%s", entry.Service, entry.Account),
 		})
 	}
-	
+
 	return result, nil
 }
 
@@ -182,9 +182,9 @@ func (p *Provider) DeleteEntry(id string) error {
 	if len(parts) != 2 {
 		return fmt.Errorf("invalid entry ID format: expected 'service:account', got %q", id)
 	}
-	
+
 	service, account := parts[0], parts[1]
-	
+
 	if account == "" {
 		var err error
 		account, err = getCurrentUser()
@@ -192,11 +192,11 @@ func (p *Provider) DeleteEntry(id string) error {
 			return fmt.Errorf("could not determine current user: %w", err)
 		}
 	}
-	
+
 	if err := p.keychain.DeleteEntry(account, service); err != nil {
 		return fmt.Errorf("failed to delete TOTP entry: %w", err)
 	}
-	
+
 	return nil
 }
 
@@ -206,7 +206,7 @@ func getCurrentUser() (string, error) {
 	if cmd != "" {
 		return cmd, nil
 	}
-	
+
 	return "", fmt.Errorf("could not determine current user")
 }
 
@@ -226,24 +226,24 @@ func parseServiceKey(serviceKey string) (serviceName, profile string) {
 	if !strings.HasPrefix(serviceKey, defaultServicePrefix+"-") {
 		return serviceKey, ""
 	}
-	
+
 	parts := strings.SplitN(serviceKey, defaultServicePrefix+"-", 2)
 	if len(parts) != 2 {
 		return serviceKey, ""
 	}
-	
+
 	remainder := parts[1]
-	
+
 	// Check if there's a profile (additional hyphen)
 	profileParts := strings.Split(remainder, "-")
 	if len(profileParts) == 1 {
 		// No profile
 		return remainder, ""
 	}
-	
+
 	// Last part is the profile, the rest is the service name
 	serviceName = strings.Join(profileParts[:len(profileParts)-1], "-")
 	profile = profileParts[len(profileParts)-1]
-	
+
 	return serviceName, profile
-}
\ No newline at end of file
+}
diff --git a/internal/setup/interface.go b/internal/setup/interface.go
index 3bb33bc..6d9a362 100644
--- a/internal/setup/interface.go
+++ b/internal/setup/interface.go
@@ -19,4 +19,4 @@ func (w DefaultWizardRunner) Run() error {
 func (w DefaultWizardRunner) RunForService(serviceName string) error {
 	RunWizardForService(serviceName)
 	return nil
-}
\ No newline at end of file
+}
diff --git a/internal/setup/mocks/setup_mock.go b/internal/setup/mocks/setup_mock.go
index 705b481..a62cf49 100644
--- a/internal/setup/mocks/setup_mock.go
+++ b/internal/setup/mocks/setup_mock.go
@@ -25,4 +25,4 @@ func (m *MockWizardRunner) RunForService(serviceName string) error {
 		return m.RunForServiceFunc(serviceName)
 	}
 	return nil
-}
\ No newline at end of file
+}
diff --git a/internal/setup/setup.go b/internal/setup/setup.go
index 82242b2..d58ce62 100644
--- a/internal/setup/setup.go
+++ b/internal/setup/setup.go
@@ -21,20 +21,20 @@ func GetCurrentExecutablePath() string {
 			return selfPath
 		}
 	}
-	
+
 	// Otherwise, check for known installation paths
 	knownPaths := []string{
 		os.ExpandEnv("$HOME/.local/bin/sesh"),
 		"/usr/local/bin/sesh",
 		"/opt/homebrew/bin/sesh",
 	}
-	
+
 	for _, path := range knownPaths {
 		if _, err := os.Stat(path); err == nil {
 			return path
 		}
 	}
-	
+
 	// Fall back to the default as a last resort
 	return "/usr/local/bin/sesh"
 }
@@ -177,7 +177,7 @@ func setupAWS() {
 		"-a", user,
 		"-s", serviceName,
 		"-w", string(secret),
-		"-U", // Update if exists
+		"-U",           // Update if exists
 		"-T", execPath, // Only allow the sesh binary to access this item
 	)
 	err = addCmd.Run()
@@ -195,7 +195,7 @@ func setupAWS() {
 		"-a", user,
 		"-s", serialServiceName,
 		"-w", mfaArn,
-		"-U", // Update if exists
+		"-U",           // Update if exists
 		"-T", execPath, // Only allow the sesh binary to access this item
 	)
 	err = addSerialCmd.Run()
@@ -262,7 +262,7 @@ func setupGenericTOTP() {
 		"-a", user,
 		"-s", serviceKey,
 		"-w", string(secret),
-		"-U", // Update if exists
+		"-U",           // Update if exists
 		"-T", execPath, // Only allow the sesh binary to access this item
 	)
 
@@ -302,4 +302,4 @@ func getCurrentUser() string {
 	fmt.Println("‚ùå Could not determine current user")
 	os.Exit(1)
 	return "" // Will never reach here, but needed for compilation
-}
\ No newline at end of file
+}
diff --git a/internal/setup/setup_test.go b/internal/setup/setup_test.go
index c0aa33d..f726c9a 100644
--- a/internal/setup/setup_test.go
+++ b/internal/setup/setup_test.go
@@ -66,18 +66,18 @@ func TestWizardErrorHandling(t *testing.T) {
 func TestRunWizard(t *testing.T) {
 	// Save original function to restore it after test
 	originalFunc := RunWizardForService
-	
+
 	// Use a temp var to track if our mock was called
 	called := false
 	expectedService := "aws"
 	actualService := ""
-	
+
 	// Override the function for testing
 	RunWizardForService = func(serviceName string) {
 		called = true
 		actualService = serviceName
 	}
-	
+
 	// Restore original when done
 	defer func() {
 		RunWizardForService = originalFunc
@@ -90,7 +90,7 @@ func TestRunWizard(t *testing.T) {
 	if !called {
 		t.Error("RunWizard did not call RunWizardForService")
 	}
-	
+
 	if actualService != expectedService {
 		t.Errorf("Expected service name '%s', got '%s'", expectedService, actualService)
 	}
@@ -99,15 +99,15 @@ func TestRunWizard(t *testing.T) {
 func TestDefaultWizardRunnerRun(t *testing.T) {
 	// Save original function
 	originalFunc := RunWizard
-	
+
 	// Setup test vars
 	called := false
-	
+
 	// Replace with test version
 	RunWizard = func() {
 		called = true
 	}
-	
+
 	// Restore when done
 	defer func() {
 		RunWizard = originalFunc
@@ -129,15 +129,15 @@ func TestDefaultWizardRunnerRun(t *testing.T) {
 func TestDefaultWizardRunnerRunForService(t *testing.T) {
 	// Save original function
 	originalFunc := RunWizardForService
-	
+
 	// Setup test vars
 	serviceCalled := ""
-	
+
 	// Replace with test version
 	RunWizardForService = func(serviceName string) {
 		serviceCalled = serviceName
 	}
-	
+
 	// Restore when done
 	defer func() {
 		RunWizardForService = originalFunc
diff --git a/internal/totp/interfaces.go b/internal/totp/interfaces.go
index f8d3396..eb42146 100644
--- a/internal/totp/interfaces.go
+++ b/internal/totp/interfaces.go
@@ -1,5 +1,7 @@
 package totp
 
+import "time"
+
 // Provider defines the interface for TOTP operations
 type Provider interface {
 	// Generate generates a single TOTP code
@@ -7,6 +9,9 @@ type Provider interface {
 
 	// GenerateConsecutiveCodes generates two consecutive TOTP codes
 	GenerateConsecutiveCodes(secret string) (current string, next string, err error)
+	
+	// GenerateForTime generates a TOTP code for a specific time
+	GenerateForTime(secret string, t time.Time) (string, error)
 }
 
 // DefaultProvider is the default implementation using otp library
@@ -25,6 +30,11 @@ func (p *DefaultProvider) GenerateConsecutiveCodes(secret string) (current strin
 	return GenerateConsecutiveCodes(secret)
 }
 
+// GenerateForTime implements the Provider interface
+func (p *DefaultProvider) GenerateForTime(secret string, t time.Time) (string, error) {
+	return GenerateForTime(secret, t)
+}
+
 // NewDefaultProvider creates a new DefaultProvider
 func NewDefaultProvider() Provider {
 	return &DefaultProvider{}
diff --git a/internal/totp/totp.go b/internal/totp/totp.go
index cec78ce..8663b50 100644
--- a/internal/totp/totp.go
+++ b/internal/totp/totp.go
@@ -24,6 +24,19 @@ func Generate(secret string) (string, error) {
 	return code, nil
 }
 
+// GenerateForTime generates a TOTP code for a specific time
+func GenerateForTime(secret string, t time.Time) (string, error) {
+	opts := totp.ValidateOpts{
+		Digits: 6,
+	}
+	
+	code, err := totp.GenerateCodeCustom(secret, t, opts)
+	if err != nil {
+		return "", fmt.Errorf("failed to generate TOTP for time %v: %w", t, err)
+	}
+	return code, nil
+}
+
 // GenerateConsecutiveCodes generates two consecutive TOTP codes for MFA device setup
 func GenerateConsecutiveCodes(secret string) (current string, next string, err error) {
 	if MockGenerateConsecutiveCodes.Enabled {
diff --git a/sesh-cli/cmd/sesh/app.go b/sesh-cli/cmd/sesh/app.go
index f45f732..babe21b 100644
--- a/sesh-cli/cmd/sesh/app.go
+++ b/sesh-cli/cmd/sesh/app.go
@@ -25,16 +25,16 @@ type ExitFunc func(code int)
 
 // App represents the main application
 type App struct {
-	Registry    *provider.Registry
-	AWS         aws.Provider
-	Keychain    keychain.Provider
-	TOTP        totp.Provider
-	SetupWizard setup.WizardRunner
+	Registry     *provider.Registry
+	AWS          aws.Provider
+	Keychain     keychain.Provider
+	TOTP         totp.Provider
+	SetupWizard  setup.WizardRunner
 	ExecLookPath ExecLookPathFunc
-	Exit        ExitFunc
-	Stdout      io.Writer
-	Stderr      io.Writer
-	VersionInfo VersionInfo
+	Exit         ExitFunc
+	Stdout       io.Writer
+	Stderr       io.Writer
+	VersionInfo  VersionInfo
 }
 
 // VersionInfo contains version information
@@ -55,27 +55,27 @@ func initializeBinaryPath() {
 func NewDefaultApp() *App {
 	// Initialize binary path for keychain security
 	initializeBinaryPath()
-	
+
 	app := &App{
-		Registry:    provider.NewRegistry(),
-		AWS:         aws.NewDefaultProvider(),
-		Keychain:    keychain.NewDefaultProvider(),
-		TOTP:        totp.NewDefaultProvider(),
-		SetupWizard: setup.DefaultWizardRunner{},
+		Registry:     provider.NewRegistry(),
+		AWS:          aws.NewDefaultProvider(),
+		Keychain:     keychain.NewDefaultProvider(),
+		TOTP:         totp.NewDefaultProvider(),
+		SetupWizard:  setup.DefaultWizardRunner{},
 		ExecLookPath: exec.LookPath,
-		Exit:        os.Exit,
-		Stdout:      os.Stdout,
-		Stderr:      os.Stderr,
+		Exit:         os.Exit,
+		Stdout:       os.Stdout,
+		Stderr:       os.Stderr,
 		VersionInfo: VersionInfo{
 			Version: version,
 			Commit:  commit,
 			Date:    date,
 		},
 	}
-	
+
 	// Register providers
 	app.registerProviders()
-	
+
 	return app
 }
 
@@ -88,7 +88,7 @@ func (a *App) registerProviders() {
 		a.TOTP,
 		a.SetupWizard,
 	))
-	
+
 	// Register generic TOTP provider
 	a.Registry.RegisterProvider(totpProvider.NewProvider(
 		a.Keychain,
@@ -106,7 +106,7 @@ func (a *App) ShowVersion() {
 // ListProviders lists all available service providers
 func (a *App) ListProviders() {
 	fmt.Fprintln(a.Stdout, "Available service providers:")
-	
+
 	for _, p := range a.Registry.ListProviders() {
 		fmt.Fprintf(a.Stdout, "  %-10s %s\n", p.Name(), p.Description())
 	}
@@ -118,23 +118,23 @@ func (a *App) ListEntries(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	entries, err := p.ListEntries()
 	if err != nil {
 		return fmt.Errorf("failed to list entries: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stdout, "Entries for %s:\n", serviceName)
 	if len(entries) == 0 {
 		fmt.Fprintln(a.Stdout, "  No entries found")
 		return nil
 	}
-	
+
 	for _, entry := range entries {
-		fmt.Fprintf(a.Stdout, "  %-20s %s [ID: %s]\n", 
+		fmt.Fprintf(a.Stdout, "  %-20s %s [ID: %s]\n",
 			entry.Name, entry.Description, entry.ID)
 	}
-	
+
 	return nil
 }
 
@@ -144,11 +144,11 @@ func (a *App) DeleteEntry(serviceName, entryID string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	if err := p.DeleteEntry(entryID); err != nil {
 		return fmt.Errorf("failed to delete entry: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stdout, "‚úÖ Entry deleted successfully\n")
 	return nil
 }
@@ -159,7 +159,7 @@ func (a *App) RunSetup(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	return p.Setup()
 }
 
@@ -169,18 +169,18 @@ func (a *App) GenerateCredentials(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stderr, "üîê Generating credentials for %s...\n", serviceName)
 	startTime := time.Now()
-	
+
 	creds, err := p.GetCredentials()
 	if err != nil {
 		return fmt.Errorf("failed to generate credentials: %w", err)
 	}
-	
+
 	elapsedTime := time.Since(startTime)
 	fmt.Fprintf(a.Stderr, "‚úÖ Credentials acquired in %.2fs\n", elapsedTime.Seconds())
-	
+
 	a.PrintCredentials(creds)
 	return nil
 }
@@ -191,24 +191,24 @@ func (a *App) CopyToClipboard(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stderr, "üîê Generating credentials for %s...\n", serviceName)
 	startTime := time.Now()
-	
+
 	creds, err := p.GetCredentials()
 	if err != nil {
 		return fmt.Errorf("failed to generate credentials: %w", err)
 	}
-	
+
 	elapsedTime := time.Since(startTime)
-	
+
 	if err := clipboard.Copy(creds.CopyValue); err != nil {
 		return fmt.Errorf("failed to copy to clipboard: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stderr, "‚úÖ Code copied to clipboard in %.2fs\n", elapsedTime.Seconds())
 	fmt.Fprintf(a.Stdout, "# %s\n", creds.DisplayInfo)
-	
+
 	return nil
 }
 
@@ -217,7 +217,7 @@ func (a *App) PrintCredentials(creds provider.Credentials) {
 	for key, value := range creds.Variables {
 		fmt.Fprintf(a.Stdout, "export %s=%s\n", key, value)
 	}
-	
+
 	// Format expiry time
 	expiryDisplay := "unknown"
 	if !creds.Expiry.IsZero() {
@@ -227,10 +227,10 @@ func (a *App) PrintCredentials(creds provider.Credentials) {
 		expiryDisplay = fmt.Sprintf("%s (valid for %dh%dm)",
 			creds.Expiry.Local().Format("2006-01-02 15:04:05"), hours, minutes)
 	}
-	
+
 	fmt.Fprintf(a.Stdout, "# ‚è≥ Expires at: %s\n", expiryDisplay)
-	
+
 	if creds.DisplayInfo != "" {
 		fmt.Fprintf(a.Stdout, "# %s\n", creds.DisplayInfo)
 	}
-}
\ No newline at end of file
+}
diff --git a/sesh-cli/cmd/sesh/app_test.go b/sesh-cli/cmd/sesh/app_test.go
index 653296b..afe20cb 100644
--- a/sesh-cli/cmd/sesh/app_test.go
+++ b/sesh-cli/cmd/sesh/app_test.go
@@ -97,13 +97,13 @@ func TestNewDefaultApp(t *testing.T) {
 	if app.Stderr == nil {
 		t.Error("Stderr is nil")
 	}
-	
+
 	// Check that providers are registered
 	providers := app.Registry.ListProviders()
 	if len(providers) == 0 {
 		t.Error("No providers registered")
 	}
-	
+
 	// Check AWS provider is registered
 	awsProvider, err := app.Registry.GetProvider("aws")
 	if err != nil {
@@ -112,7 +112,7 @@ func TestNewDefaultApp(t *testing.T) {
 	if awsProvider == nil {
 		t.Error("AWS provider is nil")
 	}
-	
+
 	// Check TOTP provider is registered
 	totpProvider, err := app.Registry.GetProvider("totp")
 	if err != nil {
diff --git a/sesh-cli/cmd/sesh/main.go b/sesh-cli/cmd/sesh/main.go
index b1f3f5c..8d12b7d 100644
--- a/sesh-cli/cmd/sesh/main.go
+++ b/sesh-cli/cmd/sesh/main.go
@@ -66,10 +66,10 @@ func run(app *App, args []string) {
 		app.Exit(1)
 		return
 	}
-	
+
 	// Set up provider flags
 	provider.SetupFlags(fs)
-	
+
 	// Do a full parse now that all flags are registered
 	// Reset flag values in case they were set incorrectly in the first pass
 	fs.Visit(func(f *flag.Flag) {
@@ -77,10 +77,10 @@ func run(app *App, args []string) {
 			fmt.Fprintf(app.Stderr, "DEBUG: List flag was set in first pass to %v\n", *listEntries)
 		}
 	})
-	
+
 	// Parse the flags again, with all provider flags registered
 	fs = flag.NewFlagSet(args[0], flag.ExitOnError)
-	
+
 	// Redefine base flags
 	serviceName = fs.String("service", "aws", "Service provider to use (aws, totp)")
 	showVersion = fs.Bool("version", false, "Show version information")
@@ -90,10 +90,10 @@ func run(app *App, args []string) {
 	deleteEntry = fs.String("delete", "", "Delete entry for selected service (specify entry ID)")
 	runSetup = fs.Bool("setup", false, "Run setup wizard for selected service")
 	copyClipboard = fs.Bool("clip", false, "Copy code to clipboard instead of printing credentials")
-	
+
 	// Setup provider flags
 	provider.SetupFlags(fs)
-	
+
 	// Parse all flags
 	if err := fs.Parse(args[1:]); err != nil {
 		fmt.Fprintf(app.Stderr, "Error parsing arguments: %v\n", err)
@@ -169,4 +169,4 @@ func printUsage() {
 	fmt.Println("  sesh --list-services                   List available service providers")
 	fmt.Println("  sesh --service totp --list             List all TOTP services")
 	fmt.Println("  sesh --service totp --setup            Run setup wizard for TOTP")
-}
\ No newline at end of file
+}
diff --git a/sesh-cli/cmd/sesh/main_test.go b/sesh-cli/cmd/sesh/main_test.go
index af27c53..bc4dd90 100644
--- a/sesh-cli/cmd/sesh/main_test.go
+++ b/sesh-cli/cmd/sesh/main_test.go
@@ -22,7 +22,7 @@ func mockApp() (*App, *bytes.Buffer, *bytes.Buffer) {
 	stderrBuf := new(bytes.Buffer)
 
 	app := NewDefaultApp() // Create a real app with registry
-	
+
 	// Override with mocks
 	app.AWS = &awsMocks.MockProvider{}
 	app.Keychain = &mocks.MockProvider{}
@@ -37,7 +37,7 @@ func mockApp() (*App, *bytes.Buffer, *bytes.Buffer) {
 		Commit:  "test-commit",
 		Date:    "test-date",
 	}
-	
+
 	return app, stdoutBuf, stderrBuf
 }
 
diff --git a/sesh/cmd/sesh/app.go b/sesh/cmd/sesh/app.go
index 744ad84..1414460 100644
--- a/sesh/cmd/sesh/app.go
+++ b/sesh/cmd/sesh/app.go
@@ -25,16 +25,16 @@ type ExitFunc func(code int)
 
 // App represents the main application
 type App struct {
-	Registry    *provider.Registry
-	AWS         aws.Provider
-	Keychain    keychain.Provider
-	TOTP        totp.Provider
-	SetupWizard setup.WizardRunner
+	Registry     *provider.Registry
+	AWS          aws.Provider
+	Keychain     keychain.Provider
+	TOTP         totp.Provider
+	SetupWizard  setup.WizardRunner
 	ExecLookPath ExecLookPathFunc
-	Exit        ExitFunc
-	Stdout      io.Writer
-	Stderr      io.Writer
-	VersionInfo VersionInfo
+	Exit         ExitFunc
+	Stdout       io.Writer
+	Stderr       io.Writer
+	VersionInfo  VersionInfo
 }
 
 // VersionInfo contains version information
@@ -55,27 +55,27 @@ func initializeBinaryPath() {
 func NewDefaultApp() *App {
 	// Initialize binary path for keychain security
 	initializeBinaryPath()
-	
+
 	app := &App{
-		Registry:    provider.NewRegistry(),
-		AWS:         aws.NewDefaultProvider(),
-		Keychain:    keychain.NewDefaultProvider(),
-		TOTP:        totp.NewDefaultProvider(),
-		SetupWizard: setup.DefaultWizardRunner{},
+		Registry:     provider.NewRegistry(),
+		AWS:          aws.NewDefaultProvider(),
+		Keychain:     keychain.NewDefaultProvider(),
+		TOTP:         totp.NewDefaultProvider(),
+		SetupWizard:  setup.DefaultWizardRunner{},
 		ExecLookPath: exec.LookPath,
-		Exit:        os.Exit,
-		Stdout:      os.Stdout,
-		Stderr:      os.Stderr,
+		Exit:         os.Exit,
+		Stdout:       os.Stdout,
+		Stderr:       os.Stderr,
 		VersionInfo: VersionInfo{
 			Version: version,
 			Commit:  commit,
 			Date:    date,
 		},
 	}
-	
+
 	// Register providers
 	app.registerProviders()
-	
+
 	return app
 }
 
@@ -88,7 +88,7 @@ func (a *App) registerProviders() {
 		a.TOTP,
 		a.SetupWizard,
 	))
-	
+
 	// Register generic TOTP provider
 	a.Registry.RegisterProvider(totpProvider.NewProvider(
 		a.Keychain,
@@ -106,7 +106,7 @@ func (a *App) ShowVersion() {
 // ListProviders lists all available service providers
 func (a *App) ListProviders() {
 	fmt.Fprintln(a.Stdout, "Available service providers:")
-	
+
 	for _, p := range a.Registry.ListProviders() {
 		fmt.Fprintf(a.Stdout, "  %-10s %s\n", p.Name(), p.Description())
 	}
@@ -118,23 +118,23 @@ func (a *App) ListEntries(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	entries, err := p.ListEntries()
 	if err != nil {
 		return fmt.Errorf("failed to list entries: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stdout, "Entries for %s:\n", serviceName)
 	if len(entries) == 0 {
 		fmt.Fprintln(a.Stdout, "  No entries found")
 		return nil
 	}
-	
+
 	for _, entry := range entries {
-		fmt.Fprintf(a.Stdout, "  %-20s %s [ID: %s]\n", 
+		fmt.Fprintf(a.Stdout, "  %-20s %s [ID: %s]\n",
 			entry.Name, entry.Description, entry.ID)
 	}
-	
+
 	return nil
 }
 
@@ -144,11 +144,11 @@ func (a *App) DeleteEntry(serviceName, entryID string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	if err := p.DeleteEntry(entryID); err != nil {
 		return fmt.Errorf("failed to delete entry: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stdout, "‚úÖ Entry deleted successfully\n")
 	return nil
 }
@@ -159,7 +159,7 @@ func (a *App) RunSetup(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	return p.Setup()
 }
 
@@ -169,18 +169,18 @@ func (a *App) GenerateCredentials(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	fmt.Fprintf(a.Stderr, "üîê Generating credentials for %s...\n", serviceName)
 	startTime := time.Now()
-	
+
 	creds, err := p.GetCredentials()
 	if err != nil {
 		return fmt.Errorf("failed to generate credentials: %w", err)
 	}
-	
+
 	elapsedTime := time.Since(startTime)
 	fmt.Fprintf(a.Stderr, "‚úÖ Credentials acquired in %.2fs\n", elapsedTime.Seconds())
-	
+
 	a.PrintCredentials(creds)
 	return nil
 }
@@ -191,23 +191,23 @@ func (a *App) CopyToClipboard(serviceName string) error {
 	if err != nil {
 		return fmt.Errorf("provider not found: %w", err)
 	}
-	
+
 	// Special handling for AWS service to bypass credential generation when using -clip
 	if serviceName == "aws" {
 		return a.copyAWSTotp(p)
 	}
-	
+
 	// Standard flow for non-AWS services
 	fmt.Fprintf(a.Stderr, "üîê Generating credentials for %s...\n", serviceName)
 	startTime := time.Now()
-	
+
 	creds, err := p.GetCredentials()
 	if err != nil {
 		return fmt.Errorf("failed to generate credentials: %w", err)
 	}
-	
+
 	elapsedTime := time.Since(startTime)
-	
+
 	// Make sure we have a valid copy value
 	var copyValue string
 	if creds.CopyValue != "" {
@@ -225,17 +225,17 @@ func (a *App) CopyToClipboard(serviceName string) error {
 		}
 		copyValue = exports
 	}
-	
+
 	// Validate that we have something to copy
 	if copyValue == "" {
 		return fmt.Errorf("no content available to copy to clipboard")
 	}
-	
+
 	// Copy to clipboard
 	if err := clipboard.Copy(copyValue); err != nil {
 		return fmt.Errorf("failed to copy to clipboard: %w", err)
 	}
-	
+
 	// Show what was copied
 	var clipboardDesc string
 	switch serviceName {
@@ -244,10 +244,10 @@ func (a *App) CopyToClipboard(serviceName string) error {
 	default:
 		clipboardDesc = "value"
 	}
-	
+
 	fmt.Fprintf(a.Stderr, "‚úÖ %s copied to clipboard in %.2fs\n", clipboardDesc, elapsedTime.Seconds())
 	fmt.Fprintf(a.Stdout, "%s\n", creds.DisplayInfo)
-	
+
 	return nil
 }
 
@@ -256,59 +256,59 @@ func (a *App) CopyToClipboard(serviceName string) error {
 func (a *App) copyAWSTotp(p provider.ServiceProvider) error {
 	fmt.Fprintf(a.Stderr, "üîê Generating AWS TOTP code...\n")
 	startTime := time.Now()
-	
+
 	// We need to access AWS provider's specific properties to get the profile
 	awsProvider, ok := p.(*awsProvider.Provider)
 	if !ok {
 		return fmt.Errorf("failed to convert to AWS provider")
 	}
-	
+
 	// Access the AWS provider's TOTP generator and keychain
 	profile := awsProvider.GetProfile()
 	keyUser, keyName, err := awsProvider.GetTOTPKeyInfo()
 	if err != nil {
 		return fmt.Errorf("failed to get TOTP key info: %w", err)
 	}
-	
+
 	// Get the secret directly using the keychain provider
 	secret, err := a.Keychain.GetSecret(keyUser, keyName)
 	if err != nil {
 		return fmt.Errorf("could not retrieve TOTP secret: %w", err)
 	}
-	
+
 	// Generate codes directly using the TOTP provider
 	currentCode, nextCode, err := a.TOTP.GenerateConsecutiveCodes(secret)
 	if err != nil {
 		return fmt.Errorf("could not generate TOTP codes: %w", err)
 	}
-	
+
 	// Copy the current code to clipboard
 	if err := clipboard.Copy(currentCode); err != nil {
 		return fmt.Errorf("failed to copy to clipboard: %w", err)
 	}
-	
+
 	// Calculate seconds left and elapsed time
 	secondsLeft := 30 - (time.Now().Unix() % 30)
 	elapsedTime := time.Since(startTime)
-	
+
 	// Display a simple confirmation message
 	fmt.Fprintf(a.Stderr, "‚úÖ AWS code '%s' copied to clipboard in %.2fs\n", currentCode, elapsedTime.Seconds())
-	
+
 	// Profile-specific message
 	profileDisplay := "default profile"
 	if profile != "" {
 		profileDisplay = fmt.Sprintf("profile: %s", profile)
 	}
-	
+
 	// Print concise but useful information to stdout
 	fmt.Fprintf(a.Stdout, "üîë AWS Login Code (%s)\n\n", profileDisplay)
 	fmt.Fprintf(a.Stdout, "Current: %s  |  Next: %s  |  Time remaining: %ds\n", currentCode, nextCode, secondsLeft)
-	
+
 	// Add warning if we're close to expiry
 	if secondsLeft < 5 {
 		fmt.Fprintln(a.Stdout, "‚ö†Ô∏è  Warning: Code expires in less than 5 seconds!")
 	}
-	
+
 	return nil
 }
 
@@ -323,22 +323,22 @@ func (a *App) PrintCredentials(creds provider.Credentials) {
 		expiryDisplay = fmt.Sprintf("%s (valid for %dh%dm)",
 			creds.Expiry.Local().Format("2006-01-02 15:04:05"), hours, minutes)
 	}
-	
+
 	// First show human-readable information
 	fmt.Fprintf(a.Stdout, "‚è≥ Expires at: %s\n", expiryDisplay)
-	
+
 	if creds.DisplayInfo != "" {
 		fmt.Fprintf(a.Stdout, "%s\n", creds.DisplayInfo)
 	}
-	
-	// Then add a separator before environment variables 
+
+	// Then add a separator before environment variables
 	fmt.Fprintf(a.Stdout, "\n# --------- ENVIRONMENT VARIABLES ---------\n")
-	
+
 	// Output export commands
 	for key, value := range creds.Variables {
 		fmt.Fprintf(a.Stdout, "export %s=%s\n", key, value)
 	}
-	
+
 	// Add a separator after environment variables
 	fmt.Fprintf(a.Stdout, "# ----------------------------------------\n")
-}
\ No newline at end of file
+}
